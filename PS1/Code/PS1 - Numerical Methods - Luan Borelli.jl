# Importing useful packages:
using Random, Distributions # Statistical packages. 
using Plots # For plotting. 
using ARCHModels # This package is necessary for the estimation of AR(1) processes. If not installed, run: using Pkg; Pkg.add("ARCHModels" )

Random.seed!(1337) # Setting seed for replicability.

#######################
## Defining functions #
#######################

# As explained in the LaTeX document, 
I start by defining several functions that will be used to obtain the requested problem set results. 

######################
## Tauchen function ##
######################

# This function returns the states vector (grid points) and the transition matrix for the discrete markov process approximation 
# of an AR(1) process specified as θ_t = μ*(1-ρ) + ρ*z_{t-1} + ε_t, ε_t ~ N(0,σ^2), by Tauchen's method.
  
# N stands for the number of states in discretization of θ (must be an odd number);
# m stands for the maximum number of standard deviations from the mean.

function tauchen(mu,σsq,rho,N,m)
  
    σ = sqrt(σsq); # Standard deviation of ε.
    μ_θ = mu; # Expected value of θ_t. Notice that in this particular specification, it is exactly μ. In other specifications, it could be e.g. μ/(1-ρ).
    σ_θ = σ/sqrt(1-rho^2); # Standard deviation of θ_t.
      
    θ = range(μ_θ - m*σ_θ, μ_θ + m*σ_θ, N); # Generating grid points. 
    Δθ = θ[2]-θ[1]; # This is the width of the invervals. Notice that all the points are equidistant, by construction.
      

    # Now we calculate all the probability transition matrix elements "at once" through matrix operations. 
    # Idea: all we need to do this is to calculate a matrix of "all possible differences" of grid θ elements.
    # In general, letting 1 be a vector of ones, the matrix of all possible differences between elements
    # of vectors  u and v is given by: D := 1u' - v1'.

    θ_j = ones(N,1)*θ'; # 1u'
    θ_i = θ*ones(N,1)'; # v1'
    
    P_1 = cdf(Normal(),((θ_j - rho*θ_i .+ Δθ/2) .- (1-rho)*mu)/σ); # "Part 1" of the transition matrix. 
    P_2 = cdf(Normal(),((θ_j - rho*θ_i .- Δθ/2) .- (1-rho)*mu)/σ); # "Part 2" of the transition matrix.
  
    P = P_1 - P_2; # Transition matrix.
    
    # But the corner transition probabilities are not correct yet...
    # Fixing the corner transition probabilities by calculating them separately:
    P[:,1] = P_1[:,1]; 
    P[:,N] = -P_2[:,N] .+ 1;

    # Done! 
    return θ, P    
end 

##########################
## Rouwenhorst function ##
##########################

# This function returns the states vector (grid points) and the transition matrix for the discrete markov process approximation 
# of an AR(1) process specified as θ_t = μ*(1-ρ) + ρ*z_{t-1} + ε_t, ε_t ~ N(0,σ^2), by Rouwenhorst's method.
  
# N stands for the number of states in discretization of θ (must be an odd number).

function rouwenhorst(μ,σ,ρ,N)
    θ_1 = μ - sqrt(N-1)*σ/sqrt(1-ρ^2) # Defining the first grid point.
    θ_N = μ + sqrt(N-1)*σ/sqrt(1-ρ^2) # Defining the last grid point.
    θ_grid = range(θ_1, θ_N, N) # Generating grid points. 
    p = (1+ρ)/2 # Defining p.
    P_2 = [p 1-p; 1-p p] # Defining P_2. 
    P_prev = P_2 # At the end of the code, afther the recursion, this variable will allocate the final transition matrix.

    # Solving recursively for P_N:
    for i in 3:N 
        P_N = p*[P_prev zeros(i-1, 1); zeros(i-1, 1)' 0] + (1-p)*[zeros(i-1, 1) P_prev; 0 zeros(i-1, 1)'] + (1-p)*[zeros(i-1, 1)' 0; P_prev zeros(i-1, 1)] + p*[0 zeros(i-1, 1)'; zeros(i-1, 1) P_prev]
        P_prev = P_N 
        normalizer = repeat(sum(P_prev, dims=2), 1, i) # Matrix used to normalize the sum of each row. 
        P_prev = P_prev./normalizer # Normalizing the sum of each row to 1.
    end 

    # At this point, P_prev is the transition matrix, P_N. 

    return θ_grid, P_prev
end

#################
## AR function ##
#################

# Given the parameters mu, sigma and rho, and a sample size n, this function simulates an AR(1) process specified as 
# θ_t = μ*(1-ρ) + ρ*z_{t-1} + ε_t, ε_t ~ N(0,σ^2) 
# It returns two outputs: the time series θ_t generated by the simulated autoregressive process 
# and the series of errors ϵ_t used to generate the autoregressive process. 


function ar(mu,sigma,rho,n)
  errors = rand(Normal(0,sigma), n) # Drawing n normally distributed errors from the N(0, σ^2) distribution. 
  θ = mu*ones(n) # This vector will allocate the final generated time series. The first observation is set to to be μ.

  for i in 2:length(errors) # Constructing the time series.
    θ[i] = (1-rho)*mu + rho*θ[i-1] + errors[i] 
  end

  return θ, errors
end 

###################################################
## Discretized AR function (by Tauchen's method) ##
###################################################

function tauch_discretized_ar(mu, sigma_sq, rho, N, m, errors)

  sigma = sqrt(sigma_sq) # Just recovering sigma from sigma^2.
  tauch = tauchen(mu,sigma_sq,rho,N,m) # Running Tauchen's method. 
  theta_grid = tauch[1] # Grid of shocks generated by Tauchen's method. 
  Pi = tauch[2] # Transition matrix generated by Tauchen's method. 
  θ_tauchen = zeros(length(errors)) # This vector will allocate the final discretized time series.
  Π_cdf = hcat([accumulate(+, Pi[i,:]) for i in 1:size(Pi,1)]...)' # Obtaining the cumulative transition matrix from the transition matrix.
  θ_tauchen[1] = mu # Defining the first point of the discretized time series as the mean of the continuous AR(1) process. 

  for t in 2:length(errors) # Generating the discretized time series.
  
    # This line of code takes the position of the current shock in theta_grid.
    current_state = sum(theta_grid .<= θ_tauchen[t-1])

    # Given the current state and a new shock (errors[t]), this line of code calculates
    # to which state the discretized process will transit. 
    new_state = sum(Π_cdf[current_state,:] .< cdf(Normal(0,sigma), errors[t])) + 1

    # Defining the new discretized time series' point. 
    θ_tauchen[t] = theta_grid[new_state]
  end

  return θ_tauchen 
end

#######################################################
## Discretized AR function (by Rouwenhorst's method) ##
#######################################################

function rouw_discretized_ar(mu, sigma_sq, rho, N, errors)
  
    sigma = sqrt(sigma_sq)
    rouw = rouwenhorst(mu,sigma,rho,N)
    theta_grid = rouw[1]
    Pi = rouw[2]
    θ_rouw = zeros(length(errors)) 
    Π_cdf = hcat([accumulate(+, Pi[i,:]) for i in 1:size(Pi,1)]...)'
    θ_rouw[1] = mu
  
    for t in 2:length(errors) # Generating the discretized time series

      # This line of code takes the position of the current shock in theta_grid.
      current_state = sum(theta_grid .<= θ_rouw[t-1])  

      # Given the current state and a new shock (errors[t]), this line of code calculates
      # to which state the discretized process will transit. 
      new_state = sum(Π_cdf[current_state,:] .< cdf(Normal(0,sigma), errors[t])) + 1

      # Defining the new discretized time series' point. 
      θ_rouw[t] = theta_grid[new_state]
    end

    return θ_rouw 
end


###################
## Problem Set 1 ##
###################

# Now I finally solve the problem set exercises by using the previously defined functions.

#######
## 1 ##
#######

# Defining the parameters: 

μ = 0     # Mean 
σ = 0.007 # Standard deviation
ρ = 0.95  # Persistence
N = 9     # Number of points for discretization.
m = 3     # Number of standard deviations (for Tauchen's method)

# Discretizing by Tauchen's method: 

tauch = tauchen(μ, σ^2, ρ, N, m) # Discretizing by Tauchen's method.
tauch_grid = tauch[1] # Grid points by Tauchen's method. 
tauch_Π = tauch[2]    # Transition matrix by Tauchen's method. 

tauch_grid 
tauch_Π

#######
## 2 ##
#######

# Discretizing by Rouwenhorst's method: 

rouw = rouwenhorst(μ, σ, ρ, N) # Discretizing by Rouwenhorst's method.
rouw_grid = rouw[1] # Grid points by Tauchen's method.
rouw_Π = rouw[2] # Transition matrix by Rouwenhorst's method.

rouw_grid
rouw_Π

#######
## 3 ##
#######

# Generating the continuous AR(1) process: 

n = 10000 # Sample size
continuous_ar = ar(μ, σ, ρ, n)
ts = continuous_ar[1] # AR(1) time series. 
ε = continuous_ar[2] # AR(1) errors. 

# Generating the discretized AR(1) processes: 
discrete_ar_tauch = tauch_discretized_ar(μ, σ^2, ρ, N, m, ε) # Discretized AR(1) process by Tauchen's method. 
discrete_ar_rouw = rouw_discretized_ar(μ, σ^2, ρ, N, ε) # Discretized AR(1) process by Rouwenhorst's method. 

# Plotting continuous and Tauchen's discretized processes together: 

plt_tauch = plot(1:length(ts), ts, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_tauch), discrete_ar_tauch, label="Tauchen", color="red", alpha=0.5, lw=3)

for i in 1:length(tauch_grid)
  hline!([tauch_grid[i] tauch_grid[i]], color="red", alpha=0.3, linestyle=:dash, label="")
end

display(plt_tauch)
# savefig(plt_tauch, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/c_t_plot.png") # Exporting the plot to a .png file.

# Plotting continuous and Rouwenhorst's discretized processes together: 

plt_rouw = plot(1:length(ts), ts, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_rouw), discrete_ar_rouw, label="Rouwenhorst", color="blue", alpha=0.5, lw=3)

for i in 1:length(tauch_grid) # Plotting horizontal lines at each discrete grid point level.
  hline!([rouw_grid[i] rouw_grid[i]], color="blue", alpha=0.3, linestyle=:dash, label="")
end

display(plt_rouw)
# savefig(plt_rouw, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/c_r_plot.png") # Exporting the plot to a .png file.

# Plotting continuous and Tauchen's/Rouwenhorst's discretized processes all together: 

plt = plot(1:length(ts), ts, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_tauch), discrete_ar_tauch, label="Tauchen", color="red", alpha=0.5, lw=3)
plot!(1:length(discrete_ar_rouw), discrete_ar_rouw, label="Rouwenhorst", color="blue", alpha=0.5, lw=3)

for i in 1:length(tauch_grid) # Plotting horizontal lines at each discrete grid point level. 
  hline!([tauch_grid[i] tauch_grid[i]], color="red", alpha=0.3, linestyle=:dash, label="")
  hline!([rouw_grid[i] rouw_grid[i]], color="blue", alpha=0.3, linestyle=:dash, label="")
end

display(plt)
# savefig(plt, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/c_t_r_plot.png") # Exporting the plot to a .png file.

# Mean Squared Errors for Tauchen and Rouwenhorst:
msqe_tauch = mean((ts .- discrete_ar_tauch).^2)*100
msqe_rouw = mean((ts .- discrete_ar_rouw).^2)*100
relative_msqe = msqe_tauch/msqe_rouw

print("\n MSQE Tauchen: ", msqe_tauch, "\n") # Tauchen 
print("\n MSQE Rouwenhorst: ", msqe_rouw, "\n") # Rouwenhorst
print("\n Relative MSQE: ", relative_msqe, "\n") # Relative MSQE (a value above unity implies that Rouwenhorst is performing better)

#######
## 4 ##
#######

# Defining a function that fits an AR(1) process to a given time series:
fit_ar1(data) = fit(ARCH{0}, data, meanspec = ARMA{1,0}) 

# Obtaining the estimated coefficients for each process: 
continuous_estimate = coef(fit_ar1(ts))[3] # Fitting the continuous AR(1) process. 
tauch_estimate = coef(fit_ar1(discrete_ar_tauch))[3] # Fitting the discretized (by Tauchen) AR(1) process. 
rouw_estimate = coef(fit_ar1(discrete_ar_rouw))[3] # Fitting the discretized (by Rouwenhorst) AR(1) process. 

# Calculating the errors with respect to the real DGP coefficient: 
continuous_estimate_error = abs(ρ - continuous_estimate)
tauch_estimate_error = abs(ρ - tauch_estimate)
rouw_estimate_error = abs(ρ - rouw_estimate)

#######
## 5 ##
#######

# Replicating all the above results for ρ = 0.99:

ρ_5 = 0.99

# (1) 

tauch_5 = tauchen(μ, σ^2, ρ_5, N, m)
tauch_grid_5 = tauch_5[1] # Grid points by Tauchen's method. 
tauch_Π_5 = tauch_5[2]    # Transition matrix by Tauchen's method. 

tauch_grid_5
tauch_Π_5

# (2)

rouw_5 = rouwenhorst(μ, σ, ρ_5, N)
rouw_grid_5 = rouw_5[1]
rouw_Π_5 = rouw_5[2] 

rouw_grid_5
rouw_Π_5 

# (3) 

# Generating the continuous AR(1) process, with ρ = 0.99: 
continuous_ar_5 = ar(μ, σ, ρ_5, n)
ts_5 = continuous_ar_5[1] # AR(1) time series. 
ε_5 = continuous_ar_5[2] # AR(1) errors. 

discrete_ar_tauch_5 = tauch_discretized_ar(μ, σ^2, ρ_5, N, m, ε_5)
discrete_ar_rouw_5 = rouw_discretized_ar(μ, σ^2, ρ_5, N, ε_5)


# Plotting continuous and Tauchen's discretized processes together, with ρ = 0.99: 

plt_tauch_5 = plot(1:length(ts_5), ts_5, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_tauch_5), discrete_ar_tauch_5, label="Tauchen", color="red", alpha=0.5, lw=3)

for i in 1:length(tauch_grid_5)
  hline!([tauch_grid_5[i] tauch_grid_5[i]], color="red", alpha=0.3, linestyle=:dash, label="")
end

display(plt_tauch_5)
# savefig(plt_tauch_5, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/c_t_plot_5.png") # Exporting the plot to a .png file.

# Plotting continuous and Rouwenhorst's discretized processes together, with ρ = 0.99: 

plt_rouw_5 = plot(1:length(ts_5), ts_5, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_rouw_5), discrete_ar_rouw_5, label="Rouwenhorst", color="blue", alpha=0.5, lw=3)

for i in 1:length(tauch_grid_5)
  hline!([rouw_grid_5[i] rouw_grid_5[i]], color="blue", alpha=0.3, linestyle=:dash, label="")
end

display(plt_rouw_5)
# savefig(plt_rouw_5, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/c_r_plot_5.png") # Exporting the plot to a .png file.

# Plotting continuous and Tauchen's/Rouwenhorst's discretized processes all together, with ρ = 0.99: 

plt_5 = plot(1:length(ts_5), ts_5, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_tauch_5), discrete_ar_tauch_5, label="Tauchen", color="red", alpha=0.5, lw=3)
plot!(1:length(discrete_ar_rouw_5), discrete_ar_rouw_5, label="Rouwenhorst", color="blue", alpha=0.5, lw=3)

for i in 1:length(tauch_grid_5)
  hline!([tauch_grid_5[i] tauch_grid_5[i]], color="red", alpha=0.3, linestyle=:dash, label="")
  hline!([rouw_grid_5[i] rouw_grid_5[i]], color="blue", alpha=0.3, linestyle=:dash, label="")
end

display(plt_5)
# savefig(plt_5, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/c_t_r_plot_5.png") # Exporting the plot to a .png file.

# Mean Squared Errors for Tauchen and Rouwenhorst, with ρ = 0.99:
msqe_tauch_5 = mean((ts_5 .- discrete_ar_tauch_5).^2)*100
msqe_rouw_5 = mean((ts_5 .- discrete_ar_rouw_5).^2)*100
relative_msqe_5 = msqe_tauch_5/msqe_rouw_5

print("\n MSQE Tauchen: ", msqe_tauch_5, "\n") # Tauchen 
print("\n MSQE Rouwenhorst: ", msqe_rouw_5, "\n") # Rouwenhorst
print("\n Relative MSQE: ", relative_msqe_5, "\n") # Relative MSQE (a value above unity implies that Rouwenhorst is performing better)

# (4) 

continuous_estimate_5 = coef(fit_ar1(ts_5))[3] # Fitting the continuous AR(1) process. 
tauch_estimate_5 = coef(fit_ar1(discrete_ar_tauch_5))[3] # Fitting the discretized (by Tauchen) AR(1) process. 
rouw_estimate_5 = coef(fit_ar1(discrete_ar_rouw_5))[3] # Fitting the discretized (by Rouwenhorst) AR(1) process. 

# Calculating the errors with respect to the real coefficient, with ρ = 0.99: 
continuous_estimate_error_5 = abs(ρ_5 - continuous_estimate_5)
tauch_estimate_error_5 = abs(ρ_5 - tauch_estimate_5)
rouw_estimate_error_5 = abs(ρ_5 - rouw_estimate_5)

################
## Appendices ##
################

######################################################
## Appendix B : n = 1000 for a better visualization ##
######################################################

# Generating a continuous AR(1) process, with n = 1000: 
n_1000 = 1000 # Sample size
continuous_ar_1000 = ar(μ, σ, ρ, n_1000) # Simulating the continuous AR(1).
ts_1000 = continuous_ar_1000[1] # Getting the simulated AR(1) time series. 
ε_1000 = continuous_ar_1000[2] # Getting the simulated AR(1) errors. 

# Generating the discretized AR(1) processes: 
discrete_ar_tauch_1000 = tauch_discretized_ar(μ, σ^2, ρ, N, m, ε_1000) # Discretized AR(1) process by Tauchen's method. 
discrete_ar_rouw_1000 = rouw_discretized_ar(μ, σ^2, ρ, N, ε_1000) # Discretized AR(1) process by Rouwenhorst's method.

# Plotting continuous and Tauchen's/Rouwenhorst's discretized processes all together: 

plt_1000 = plot(1:length(ts_1000), ts_1000, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_tauch_1000), discrete_ar_tauch_1000, label="Tauchen", color="red", alpha=0.5, lw=3)
plot!(1:length(discrete_ar_rouw_1000), discrete_ar_rouw_1000, label="Rouwenhorst", color="blue", alpha=0.5, lw=3)

for i in 1:length(tauch_grid)
  hline!([tauch_grid[i] tauch_grid[i]], color="red", alpha=0.3, linestyle=:dash, label="")
  hline!([rouw_grid[i] rouw_grid[i]], color="blue", alpha=0.3, linestyle=:dash, label="")
end

display(plt_1000)
# savefig(plt_1000, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/1000_plot.png") # Exporting the plot to a .png file.

#########################################################
## Appendix C : More grid points for the ρ = 0.99 case ##
#########################################################

discrete_ar_tauch_20 = tauch_discretized_ar(μ, σ^2, ρ_5, 20, m, ε_5)
discrete_ar_rouw_20 = rouw_discretized_ar(μ, σ^2, ρ_5, 20, ε_5)

plt_20 = plot(1:length(ts_5), ts_5, label = "Continuous AR", color="black", alpha=0.5, legend = :outertopright,size=(2000,1000), xtickfontsize=15,ytickfontsize=15, legendfontsize=18)
plot!(1:length(discrete_ar_tauch_20), discrete_ar_tauch_20, label="Tauchen", color="red", alpha=0.5, lw=3)
plot!(1:length(discrete_ar_rouw_20), discrete_ar_rouw_20, label="Rouwenhorst", color="blue", alpha=0.5, lw=3)

for i in 1:length(tauch_grid_5)
  hline!([tauch_grid_5[i] tauch_grid_5[i]], color="red", alpha=0.3, linestyle=:dash, label="")
  hline!([rouw_grid_5[i] rouw_grid_5[i]], color="blue", alpha=0.3, linestyle=:dash, label="")
end

display(plt_20)
# savefig(plt_20, "C:/Users/Luan Borelli/Desktop/EPGE/Métodos Numéricos/20_plot.png") # Exporting the plot to a .png file.